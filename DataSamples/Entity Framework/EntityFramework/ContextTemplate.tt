<# 
// $Localized_Comment_10$    You can use this text template to customize object layer code generation for 
// $Localized_Comment_20$    applications that use the Entity Framework. The template generates code based on an .edmx file.
// $Localized_Comment_30$    Before using this template, note the following:
//
//  $Localized_Comment_40$       *The name of the text template file will determine the name of the code file it generates. 
//  $Localized_Comment_50$         For example, if the text template is named TextTemplate.tt, the generated file will be named 
//  $Localized_Comment_60$         TextTemplate.vb or TextTemplate.cs.
//  $Localized_Comment_70$       *The Custom Tool property of the targeted .edmx file must be empty. For more information, 
//  $Localized_Comment_80$        see .edmx File Properties (http://go.microsoft.com/fwlink/?LinkId=139299).
//  $Localized_Comment_90$       *The SourceCsdlPath initialization below must be set to one of the following:
//  $Localized_Comment_100$                1) the path of the targeted .edmx or .csdl file
//  $Localized_Comment_110$                2) the path of the targeted .edmx or .csdl file relative to the template path
//
//  $Localized_Comment_120$   For more detailed information about using this template, see 
//  $Localized_Comment_130$   How to: Customize Object Layer Code Generation (http://go.microsoft.com/fwlink/?LinkId=139297).
//  $Localized_Comment_140$   For general information about text templates, see 
//  $Localized_Comment_150$   Generating Artifacts by Using Text Templates (http://go.microsoft.com/fwlink/?LinkId=139298)
#>
<#@ template language="C#" debug="false" hostspecific="true"#>
<#@ output extension = ".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="System.Data.Entity" #>
<#@ assembly name="System.Data.Entity.Design" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Data.Metadata.Edm" #>
<#@ import namespace="System.Data.Objects" #>
<#@ import namespace="System.Data.Objects.DataClasses" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Reflection" #>
<# UserSettings userSettings = 
        new UserSettings
        {
            SourceCsdlPath = @"EmployeeModel.edmx",
            ReferenceCsdlPaths = new string [] {},
            FullyQualifySystemTypes = true,
            CreateContextAddToMethods = true,
        };

ApplyUserSettings(userSettings);
Edm = new ItemCollectionWrapper(SourceCsdlPath, EdmToObjectNamespaceMap, ReferenceCsdlPaths, FullyQualifySystemTypes.Value, Errors, GetNamespaceSuggestion());
#>
//------------------------------------------------------------------------------
// <auto-generated>
// <#=GetResourceString("Template_GeneratedCodeCommentLine1")#>
//
// <#=GetResourceString("Template_GeneratedCodeCommentLine2")#>
// <#=GetResourceString("Template_GeneratedCodeCommentLine3")#>
// </auto-generated>
//------------------------------------------------------------------------------

using System.Data.EntityClient;
using System.Data.Objects;
using System.Diagnostics.CodeAnalysis;
using EmployeeTracker.Common;
using EmployeeTracker.Model;

<#
    if(!String.IsNullOrEmpty(Edm.ObjectNamespace))
    {
#>
namespace <#=Edm.ObjectNamespace#>
{
<#
        PushIndent(String.Empty.PadLeft(STANDARD_INDENT_LENGTH));
    }

    ////////
    //////// $Localized_Comment_170$ Write EntityContainer and ObjectContext classes.
    ////////

    BeginRegion(GetResourceString("Template_RegionContexts"));
    foreach(EntityContainerCodeWrapper container in Edm.SourceEntityContainers)
    {
#>
/// <summary>
/// <#=container.SummaryComment#>
/// </summary><#=container.GetLongDescriptionComment(_regionIndentLevel)#>
[SuppressMessage("Microsoft.Design", "CA1063:ImplementIDisposableCorrectly", Justification = "IDisposable is specified by IEmployeeContext and the implementation is inherited from ObjectContext")]
<#=container.TypeAccessibility#> partial class <#=container.ClassName#> : ObjectContext, IEmployeeContext
{
    #region Constructors
    /// <summary>
    /// <#=String.Format(CultureInfo.CurrentCulture, GetResourceString("Template_ContextDefaultCtorComment"), container.ClassName, container.ModelName)#>
    /// </summary>
    public <#=container.ClassName#>() : base("name=<#=container.ModelName#>", "<#=container.ModelName#>")
    {
        this.ContextOptions.LazyLoadingEnabled = true;
        OnContextCreated();
    }

    /// <summary>
    /// <#=String.Format(CultureInfo.CurrentCulture, GetResourceString("Template_ContextCommonCtorComment"), container.ClassName)#>
    /// </summary>
    public <#=container.ClassName#>(string connectionString) : base(connectionString, "<#=container.ModelName#>")
    {
        this.ContextOptions.LazyLoadingEnabled = true;
        OnContextCreated();
    }

    /// <summary>
    /// <#=String.Format(CultureInfo.CurrentCulture, GetResourceString("Template_ContextCommonCtorComment"), container.ClassName)#>
    /// </summary>
    public <#=container.ClassName#>(EntityConnection connection) : base(connection, "<#=container.ModelName#>")
    {
        this.ContextOptions.LazyLoadingEnabled = true;
        OnContextCreated();
    }
    #endregion
	
    #region Partial Methods
    partial void OnContextCreated();
    #endregion
	
    #region IEmployeeContext
	
	/// <summary>
    /// Save all pending changes to the data context
    /// </summary>
    public void Save()
    {
        this.SaveChanges();
    }
	
	/// <summary>
    /// Checks if the supplied object is tracked in this data context
    /// </summary>
    /// <param name="obj">The object to check for</param>
    /// <returns>True if the object is tracked, false otherwise</returns>
    public bool IsObjectTracked(object entity)
    {
        ObjectStateEntry ose;
        return this.ObjectStateManager.TryGetObjectStateEntry(entity, out ose);
    }
	
    #endregion
    
<#
        ////////
        //////// $Localized_Comment_180$ Write EntityContainer and ObjectContext ObjectSet properties.
        ////////
        BeginRegion(GetResourceString("Template_RegionObjectSetProperties"));
        foreach(EntitySetObjectSetPropertyWrapper set in container.ObjectSetProperties)
        {
#>
    /// <summary>
    /// <#=set.SummaryComment#>
    /// </summary><#=set.GetLongDescriptionComment(_regionIndentLevel)#>
    <#=set.NewModifier#><#=set.GetterAccessibility#> IObjectSet<<#=set.TypeName#>> <#=set.PropertyName#>
    {
        get
        {
            if ((<#=set.FieldName#> == null))
            {
                <#=set.FieldName#> = base.CreateObjectSet<<#=set.TypeName#>>("<#=set.ModelName#>");
            }
            return <#=set.FieldName#>;
        }
    }
    private ObjectSet<<#=set.TypeName#>> <#=set.FieldName#>;

<#
        }
        EndRegion();

       ////////
        //////// $Localized_Comment_190$ Write EntityContainer and ObjectContext AddTo<EntitySet> methods.
        ////////
        //////// $Localized_Comment_200$ AddTo methods are no longer necessary since the EntitySet properties return 
        //////// $Localized_Comment_210$ an ObjectSet<T> object,  which has already has an Add method.
        //////// 
        //////// $Localized_Comment_220$ AddTo methods are generated here for backwards compatibility reasons only.
        //////// $Localized_Comment_230$ Set the CreateContextAddToMethods property of the UserSettings object to false 
        //////// $Localized_Comment_240$ to turn off generation of the AddTo methods.
        ////////
        BeginRegion(GetResourceString("Template_RegionAddToMethods"));
        IEnumerable<EntitySetAddToMethodWrapper> addToMethods = CreateContextAddToMethods.Value ? container.AddToMethods : Enumerable.Empty<EntitySetAddToMethodWrapper>();
        foreach(EntitySetAddToMethodWrapper addTo in addToMethods)
        {
#>
        
    /// <summary>
    /// <#=addTo.SummaryComment#>
    /// </summary>
    <#=addTo.EntityAccessibility#> void AddTo<#=addTo.ModelName#>(<#=addTo.TypeName#> <#=addTo.Parameter#>)
    {
        base.AddObject("<#=addTo.ModelName#>", <#=addTo.Parameter#>);
    }
<#
        }
        EndRegion();

        ////////
        //////// $Localized_Comment_250$ Write EntityContainer and ObjectContext Function Import methods.
        ////////
        BeginRegion(GetResourceString("Template_RegionFunctionImports"));
        foreach(FunctionImportMethodWrapper edmFunction in container.FunctionImports)
        {
#>

    /// <summary>
    /// <#=edmFunction.SummaryComment#>
    /// </summary><#=edmFunction.GetLongDescriptionComment(_regionIndentLevel)#><#=edmFunction.ParameterComments#>
    <#=edmFunction.NewModifier#><#=edmFunction.MethodAccessibility#><#=edmFunction.ReturnElementTypeName == null ? " int" : " ObjectResult<" + edmFunction.ReturnElementTypeName + ">"#> <#=edmFunction.FunctionName#>(<#=edmFunction.ParameterList#>)
    {
<#
            foreach(FunctionImportParameterWrapper parameter in edmFunction.Parameters)
            {
                if(!parameter.NeedsLocalVariable)
                    continue;
#>

        ObjectParameter <#=parameter.LocalVariableName#>;
        if (<#=parameter.IsNullableT ? parameter.FunctionParameterName + ".HasValue" : parameter.FunctionParameterName + " != null"#>)
        {
            <#=parameter.LocalVariableName#> = new ObjectParameter("<#=parameter.EsqlParameterName#>", <#=parameter.FunctionParameterName#>);
        }
        else
        {
            <#=parameter.LocalVariableName#> = new ObjectParameter("<#=parameter.EsqlParameterName#>", typeof(<#=parameter.RawClrTypeName#>));
        }
<#
            }
#>
        return <#=edmFunction.ReturnElementTypeName == null ? "base.ExecuteFunction" : "base.ExecuteFunction<" + edmFunction.ReturnElementTypeName + ">"#>("<#=edmFunction.ModelName#>"<#=edmFunction.QueryExecuteParameterNameList#>);
    }

<#
           if(edmFunction.ReturnElementType != null && edmFunction.ReturnElementType.BuiltInTypeKind == BuiltInTypeKind.EntityType)
           {
#>
    /// <summary>
    /// <#=edmFunction.SummaryComment#> 
    /// </summary><#=edmFunction.GetLongDescriptionComment(_regionIndentLevel)#>
    /// <param name="mergeOption"></param><#=edmFunction.ParameterComments#>
    <#=edmFunction.NewModifier#><#=edmFunction.MethodAccessibility#> ObjectResult<<#=edmFunction.ReturnElementTypeName#>> <#=edmFunction.FunctionName#>(<#=edmFunction.ParameterList#><#= string.IsNullOrEmpty(edmFunction.ParameterList) ? "" : ", " #>MergeOption mergeOption)
    {
<#
               foreach(FunctionImportParameterWrapper parameter in edmFunction.Parameters)
               {
                   if(!parameter.NeedsLocalVariable)
                       continue;
#>

        ObjectParameter <#=parameter.LocalVariableName#>;
        if (<#=parameter.IsNullableT ? parameter.FunctionParameterName + ".HasValue" : parameter.FunctionParameterName + " != null"#>)
        {
            <#=parameter.LocalVariableName#> = new ObjectParameter("<#=parameter.EsqlParameterName#>", <#=parameter.FunctionParameterName#>);
        }
        else
        {
            <#=parameter.LocalVariableName#> = new ObjectParameter("<#=parameter.EsqlParameterName#>", typeof(<#=parameter.RawClrTypeName#>));
        }
<#
                }
#>
        return base.ExecuteFunction<<#=edmFunction.ReturnElementTypeName#>>("<#=edmFunction.ModelName#>", mergeOption<#=edmFunction.QueryExecuteParameterNameList#>);
    }
<#
            }
        }
        EndRegion();
#>
}

<#
    }
    EndRegion();

    if(!String.IsNullOrEmpty(Edm.ObjectNamespace))
    {
        PopIndent();
#>
}
<#
    }
    VerifyTypeUniqueness();
#>
<#+
    
    ////////
    //////// $Localized_Comment_300$ Reusable Template Sections
    ////////

    ////////
    //////// $Localized_Comment_310$ Write Factory Method.
    ////////
    private void WriteFactoryMethod(FactoryMethodWrapper factory)
    {
        if(factory.Parameters.Count == 0)
            return;

        if(factory.HasDeclaredMemberWithName(factory.MethodName))
        {
            // $Localized_Comment_320$ 6029 is the same error number that EntityClassGenerator uses for this conflict.
            Errors.Add(new System.CodeDom.Compiler.CompilerError(SourceCsdlPath, -1, -1, "6029", 
                String.Format(CultureInfo.CurrentCulture, 
                        GetResourceString("Template_FactoryMethodNameConflict"), factory.MethodName, factory.ModelFullName)));
        }

        BeginRegion(GetResourceString("Template_RegionFactoryMethod"));
#>
    /// <summary>
    /// <#=String.Format(CultureInfo.CurrentCulture, GetResourceString("Template_FactoryMethodComment"), factory.ClassName)#>
    /// </summary><#=factory.ParameterComments#>
    public static <#=factory.ClassName#> <#=factory.MethodName#>(<#=factory.ParameterDeclarationList#>)
    {
        <#=factory.ClassName#> <#=factory.InstanceName#> = new <#=factory.ClassName#>();
<#+
        foreach(FactoryMethodParameterWrapper parameter in factory.Parameters)
        {
            if(parameter.IsComplexType)
            {
                // $Localized_Comment_330$ ComplexType initialization.
#>
        <#=factory.InstanceName#>.<#=parameter.PropertyName#> = StructuralObject.VerifyComplexObjectIsNotNull(<#=parameter.Name#>, "<#=parameter.PropertyModelName#>");
<#+
            }
            else
            {
                // $Localized_Comment_340$ PrimitiveType initialization.
#>
        <#=factory.InstanceName#>.<#=parameter.PropertyName#> = <#=parameter.Name#>;
        
<#+
            }
        }
#>
        return <#=factory.InstanceName#>;
    }
<#+
        EndRegion();
        WriteLine("");
    }
    
    
    ////////
    //////// $Localized_Comment_350$ Write PrimitiveType Properties.
    ////////
    private void WritePrimitiveTypeProperties(StructuralTypeWrapper typeWrapper, Type ultimateBaseType)
    {
        BeginRegion(GetResourceString("Template_RegionPrimitiveProperties"));
        foreach(PrimitiveTypePropertyWrapper property in typeWrapper.PrimitiveTypeProperties)
        {
#>
    /// <summary>
    /// <#=property.SummaryComment#>
    /// </summary><#=property.GetLongDescriptionComment(_regionIndentLevel)#>
    [EdmScalarPropertyAttribute(EntityKeyProperty=<#=property.CreatePrimitiveValue(property.IsKeyProperty)#>, IsNullable=<#=property.IsNullable.ToString().ToLower()#>)]
    [DataMemberAttribute()]
    <#=property.NewModifier#><#=property.PropertyAccessibility#> <#=property.PropertyType#> <#=property.Name#>
    {
        <#=property.GetterAccessibility#>get
        {
<#+             if(property.IsByteArray)
                {
#>
            return StructuralObject.GetValidValue(<#=property.FieldName#>);
<#+
                }
                else
                {
#>
            return <#=property.FieldName#>;
<#+
                }
#>
        }
        <#=property.SetterAccessibility#>set
        {
<#+
        if (property.IsKeyProperty)
            {
#>
            if (<#=property.FieldName#> != value)
            {
<#+
        PushIndent(String.Empty.PadLeft(STANDARD_INDENT_LENGTH));
            }
#>
            <#=property.ChangingMethodName#>(value);
            ReportPropertyChanging("<#=property.ModelName#>");
            <#=property.FieldName#> = StructuralObject.SetValidValue(value<#=property.SetValidValueOptionalNullableParameter#>);
            ReportPropertyChanged("<#=property.ModelName#>");
            <#=property.ChangedMethodName#>();
<#+
        if (property.IsKeyProperty)
            {
        PopIndent();
#>
            }
<#+
            }
#>
        }
            
    }
    private <#=property.PropertyType#> <#=property.FieldName#><#=property.FieldInit == null ? "" : " = " + property.FieldInit#>;
    partial void <#=property.ChangingMethodName#>(<#=property.PropertyType#> value);
    partial void <#=property.ChangedMethodName#>();
    
<#+
        }
        EndRegion();	
    }

    ////////
    //////// $Localized_Comment_360$ Write ComplexType Properties.
    ////////
    private void WriteComplexTypeProperties(StructuralTypeWrapper typeWrapper, Type ultimateBaseType)
    {
        BeginRegion(GetResourceString("Template_RegionComplexProperties"));
        foreach(ComplexTypePropertyWrapper property in typeWrapper.ComplexTypeProperties)
        {
#>

    /// <summary>
    /// <#=property.SummaryComment#>
    /// </summary><#=property.GetLongDescriptionComment(_regionIndentLevel)#>
    [EdmComplexPropertyAttribute()]
    [DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
    [XmlElement(IsNullable=true)]
    [SoapElement(IsNullable=true)]
    [DataMemberAttribute()]
    <#=property.NewModifier#><#=property.PropertyAccessibility#> <#=property.PropertyType#> <#=property.Name#>
    {
        <#=property.GetterAccessibility#>get
        {
            <#=property.FieldName#> = GetValidValue(<#=property.FieldName#>, "<#=property.ModelName#>", false, <#=property.InitializedTrackingField#>);
            <#=property.InitializedTrackingField#> = true;
            return <#=property.FieldName#>;
        }
        <#=property.SetterAccessibility#>set
        {
            <#=property.ChangingMethodName#>(value);
            ReportPropertyChanging("<#=property.ModelName#>");
            <#=property.FieldName#> = SetValidValue(<#=property.FieldName#>, value, "<#=property.ModelName#>");
            <#=property.InitializedTrackingField#> = true;
            ReportPropertyChanged("<#=property.ModelName#>");
            <#=property.ChangedMethodName#>();
        }
    }
    private <#=property.PropertyType#> <#=property.FieldName#>;
    private bool <#=property.InitializedTrackingField#>;
    partial void <#=property.ChangingMethodName#>(<#=property.PropertyType#> value);
    partial void <#=property.ChangedMethodName#>();
<#+
        }
        EndRegion();
    }
#>
<#+

    ////////
    //////// $Localized_Comment_370$ Declare Template Public Properties.
    ////////
    public string SourceCsdlPath{ get; set; }
    public IEnumerable<string> ReferenceCsdlPaths{ get; set; }
    public Nullable<bool> FullyQualifySystemTypes{ get; set; }
    public Nullable<bool> CreateContextAddToMethods{ get; set; }
    public Dictionary<string, string> EdmToObjectNamespaceMap
    { 
        get { return _edmToObjectNamespaceMap; } 
        set { _edmToObjectNamespaceMap = value; }
    }
    public Dictionary<string, string> _edmToObjectNamespaceMap = new Dictionary<string, string>();
    public Double SourceEdmVersion
    {
        get
        {
            if(Edm != null && Edm.Collection != null)
            {
                return Edm.Collection.EdmVersion;
            }
            
            return 0.0;
        }
    }
        
    ////////
    //////// $Localized_Comment_380$ Declare Template Private Properties.
    ////////
    private ItemCollectionWrapper Edm { get; set; }
    private static System.Resources.ResourceManager ResourceManager
    {
        get
        {
            if(_resourceManager == null)
            {
                System.Resources.ResourceManager resourceManager = new System.Resources.ResourceManager("System.Data.Entity.Design", typeof(System.Data.Entity.Design.MetadataItemCollectionFactory).Assembly);
                System.Threading.Interlocked.CompareExchange(ref _resourceManager, resourceManager, null);
            }
            return _resourceManager;
        }
    }
    private static System.Resources.ResourceManager _resourceManager;
    
#>
<#+
    
    ////////
    //////// $Localized_Comment_390$ UTILITY METHODS
    ////////

    private static string PascalCase(string identifier)
    {
        if (string.IsNullOrEmpty(identifier))
            return identifier;

        if (identifier.Length == 1)
            return identifier[0].ToString(CultureInfo.InvariantCulture).ToUpperInvariant();

        return identifier[0].ToString(CultureInfo.InvariantCulture).ToUpperInvariant() + identifier.Substring(1);
    }
    
    private static string CamelCase(string identifier)
    {
        if (string.IsNullOrEmpty(identifier))
            return identifier;

        if (identifier.Length == 1)
            return identifier[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant();

        return identifier[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant() + identifier.Substring(1);
    }
    
    private static string GetEnumValueString(object enumValue)
    {
        Type type = enumValue.GetType();

        return type.FullName + "." + enumValue.ToString();
    }

    private static string GetResourceString(string resourceName)
    {
        return ResourceManager.GetString(resourceName,
             null); // $Localized_Comment_400$ Take default culture.
    }

    ////////
    //////// $Localized_Comment_410$ Namespace Specific Code Generation Utility Methods
    ////////
    
    private const string GETTER_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:GetterAccess";
    private const string SETTER_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:SetterAccess";
    private const string TYPE_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:TypeAccess";
    private const string METHOD_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:MethodAccess";
    private const string ACCESS_PROTECTED  = "Protected";
    private const string ACCESS_INTERNAL = "Internal";
    private const string ACCESS_PRIVATE = "Private";
    private static readonly Dictionary<string, int> AccessibilityRankIdLookup = new Dictionary<string, int> 
    { { "private",      1},
      { "internal",     2},
      { "protected",    3},
      { "public",       4}};

    
    private static void GetPropertyAccessibility(EdmMember property, 
        out string propertyAccessibility, 
        out string getterAccessibility,
        out string setterAccessibility)
    {
        getterAccessibility = GetAccessibility(property, GETTER_ACCESS);
        int getterRank = AccessibilityRankIdLookup[getterAccessibility];
        
        setterAccessibility = GetAccessibility(property, SETTER_ACCESS);
        int setterRank = AccessibilityRankIdLookup[setterAccessibility];
        
        int propertyRank = Math.Max(getterRank, setterRank);
        if(setterRank == propertyRank)
        {
            setterAccessibility = "";
        }
        
        if(getterRank == propertyRank)
        {
            getterAccessibility = "";
        }
        
        propertyAccessibility = AccessibilityRankIdLookup.Where(v => v.Value == propertyRank).Select(v => v.Key).Single();
    }

    // $Localized_Comment_420$ Attempt to retrieve the user accessibility setting. Return “public” by default.
    private static string GetAccessibility(MetadataItem item, string name)
    {
        string accessibility;
        if(TryGetStringMetadataPropertySetting(item, name, out accessibility))
        {
            return TranslateUserAccessibilityToCSharpAccessibility(accessibility);
        }
        
        return "public";
    }
    
    private static string TranslateUserAccessibilityToCSharpAccessibility(string userAccessibility)
    {
        if(userAccessibility == ACCESS_PROTECTED)
        {
            return "protected";
        }
        else if(userAccessibility == ACCESS_INTERNAL)
        {
            return "internal";
        }
        else if(userAccessibility == ACCESS_PRIVATE)
        {
            return "private";
        }
        else
        {
            // $Localized_Comment_430$ Default to public.
            return "public";
        }
    }
    
    private static bool TryGetStringMetadataPropertySetting(MetadataItem item, string propertyName, out string value)
    {
        MetadataProperty property = item.MetadataProperties.FirstOrDefault(p => p.Name == propertyName);
        if(property == null)
        {
            value = null;
            return false;
        }
        value = (string)property.Value;
        return value != null;
    }
    
    private void VerifyTypeUniqueness()
    {
        HashSet<string> hash = new HashSet<string>();
        IEnumerable<GlobalItem> allTypes = Edm.SourceTypes;
                        
        foreach(GlobalItem type in allTypes)
        {
            if(!hash.Add(GetGlobalItemName(type)))
            {
                // $Localized_Comment_440$ 6034 is the error number used by System.Data.Entity.Design EntityClassGenerator.
                Errors.Add(new System.CodeDom.Compiler.CompilerError(SourceCsdlPath, -1, -1, "6034", 
                 String.Format(CultureInfo.CurrentCulture, 
                    GetResourceString("Template_DuplicateTopLevelType"),
                 GetGlobalItemName(type))));
            }
        }
    }
    
    protected string GetGlobalItemName(GlobalItem item)
    {
        if (item is EdmType)
        {
            // $Localized_Comment_450$ EntityType or ComplexType.
            return ((EdmType)item).Name;
        }
        else
        {
            // $Localized_Comment_460$ Must be an EntityContainer.
            return ((EntityContainer)item).Name;
        }
    }
        
    
    private const int STANDARD_INDENT_LENGTH = 4;
    private const string XMLCOMMENT_START = "///";
    private int _beforeRegionLength;
    private int _emptyRegionLength;
    private int _regionIndentLevel = -1;
    private void BeginRegion(string regionName)
    {
        _beforeRegionLength = GenerationEnvironment.Length;
        _regionIndentLevel++;
        Write(GetIndent(_regionIndentLevel));
        WriteLine("#region " + regionName);
        _emptyRegionLength = GenerationEnvironment.Length;
    }
    
    private void EndRegion()
    {
        int indentLevel = _regionIndentLevel;
        _regionIndentLevel--;
        if(_emptyRegionLength == GenerationEnvironment.Length)
            GenerationEnvironment.Length = _beforeRegionLength;
        else
        {
            Write(GetIndent(indentLevel));
            WriteLine("#endregion");
        }
    }
    
    private static string GetIndent(int indentLevel)
    {
        return String.Empty.PadLeft(indentLevel * STANDARD_INDENT_LENGTH);        
    }
    
    private string GetNamespaceSuggestion()
    {
#if !PREPROCESSED_TEMPLATE
        return this.Host.ResolveParameterValue("directiveId", "namespaceDirectiveProcessor", "namespaceHint");
#else
        return null;
#endif            
    }
    
    private void ApplyUserSettings(UserSettings userSettings)
    {
        // $Localized_Comment_470$ Setup template UserSettings.
        if(SourceCsdlPath == null)
        {
#if !PREPROCESSED_TEMPLATE
            SourceCsdlPath = Host.ResolvePath(userSettings.SourceCsdlPath);
#else
            SourceCsdlPath = userSettings.SourceCsdlPath;
#endif            
        }
        if(ReferenceCsdlPaths == null)
        {
            ReferenceCsdlPaths = userSettings.ReferenceCsdlPaths;
        }
            
        if(!FullyQualifySystemTypes.HasValue)
        {
            FullyQualifySystemTypes = userSettings.FullyQualifySystemTypes;
        }

        if(!CreateContextAddToMethods.HasValue)
        {
            CreateContextAddToMethods = userSettings.CreateContextAddToMethods;
        }
     }

    ////////
    //////// $Localized_Comment_480$ UniqueIdentifierService
    ////////
    private sealed class UniqueIdentifierService
    {
        private readonly HashSet<string> _knownIdentifiers;

        internal UniqueIdentifierService()
        {
            _knownIdentifiers = new HashSet<string>(StringComparer.Ordinal);
        }

        /// <summary>
        /// $Localized_Comment_490$ Makes the supplied identifier  unique within the scope by adding
        /// $Localized_Comment_500$ a suffix (1, 2, 3, ...), and returns the unique identifier.
        /// </summary>
        internal string AdjustIdentifier(string identifier)
        {
            // $Localized_Comment_510$ find a unique name by adding suffix as necessary
            int numberOfConflicts = 0;
            string adjustedIdentifier = identifier;
            while (!_knownIdentifiers.Add(adjustedIdentifier))
            {
                ++numberOfConflicts;
                adjustedIdentifier = identifier + numberOfConflicts.ToString(CultureInfo.InvariantCulture);
            }

            return adjustedIdentifier;
        }
    }
    
    private class UserSettings
    {
        public string SourceCsdlPath{ get; set; }
        public string [] ReferenceCsdlPaths{ get; set; }
        public bool FullyQualifySystemTypes{ get; set; }
        public bool CreateContextAddToMethods{ get; set; }
    }
    
    
    ////////
    //////// $Localized_Comment_520$ Wrapper Classes
    ////////
    private class ItemCollectionWrapper : WrapperBase
    {
        private const string EDM_NAMESPACE_HOLDER = "";
        private readonly EdmItemCollection _collection;
        private readonly string _sourceSchemaPath;

        public ItemCollectionWrapper(string sourceSchemaPath, 
        Dictionary<string, string> edmToObjectNamespaceMap, 
        IEnumerable<String> referenceSchemaPaths, 
        bool fullyQualifySystemTypes,
        System.CodeDom.Compiler.CompilerErrorCollection errorCollection,
        string objectNamespaceOverride)
        :base(edmToObjectNamespaceMap, fullyQualifySystemTypes)
        {
            if(objectNamespaceOverride != null && !edmToObjectNamespaceMap.ContainsKey(EDM_NAMESPACE_HOLDER))
            {
                edmToObjectNamespaceMap.Add(EDM_NAMESPACE_HOLDER, objectNamespaceOverride);
            }
            
            _sourceSchemaPath = Path.GetFullPath(sourceSchemaPath);
            if(IsEdmxSource)
            {
                // $Localized_Comment_530$ Ignore referenceSchemaPaths when an .edmx file is provided.
                _collection = GetEdmItemCollectionFromEdmxAndSetNamespaceName(_sourceSchemaPath, errorCollection);
            }
            else
            {
                _collection = CreateEdmItemCollection(new string [] {_sourceSchemaPath}.Union(referenceSchemaPaths), errorCollection);
            }
        }
        
        public bool IsEdmxSource{ get{ return Path.GetExtension(_sourceSchemaPath).ToLower() == ".edmx"; } }

        public EdmItemCollection Collection { get{ return _collection; }}

        public IEnumerable<EntityContainerCodeWrapper> SourceEntityContainers
        {
            get
            {
                return GetSourceSchemaTypes<EntityContainer>().Select(e => new EntityContainerCodeWrapper(e, this));
            }
        }

        public IEnumerable<EntityTypeWrapper> SourceEntities
        {
            get
            {
                return GetSourceSchemaTypes<EntityType>().Select(e => new EntityTypeWrapper(e, this));
            }
        }

        public IEnumerable<ComplexTypeWrapper> SourceComplexTypes
        {
            get
            {
                return GetSourceSchemaTypes<ComplexType>().Select(c => new ComplexTypeWrapper(c, this));
            }
        }

        public IEnumerable<AssociationCodeWrapper> SourceAssociations
        {
            get
            {
                return GetSourceSchemaTypes<AssociationType>().Select(a => new AssociationCodeWrapper(a, this));
            }
        }
        
        public IEnumerable<GlobalItem> SourceTypes
        {
            get
            {
                return GetSourceSchemaTypes<GlobalItem>().Where(i => i is StructuralType || i is EntityContainer);
            }
        }

        IEnumerable<T> GetSourceSchemaTypes<T>() where T : GlobalItem
        {
            if(!IsEdmxSource)
            {
                return _collection.GetItems<T>().Where(e => e.MetadataProperties.Any(mp => mp.Name == "SchemaSource" && (string)mp.Value == _sourceSchemaPath));
            }
            else
            {
                return _collection.GetItems<T>();
            }
        }
                
        public IEnumerable<EntityTypeWrapper>  GetAllDirectSubTypes(EntityType entity)
        {
            // $Localized_Comment_540$ Do not limit to Soucre Types.
            return _collection.GetItems<EntityType>().Where(b => b.BaseType == entity).Select(e => new EntityTypeWrapper(e, this));
        }

        public string ObjectNamespace
        {
            get
            {
                if(ModelNamespace == null)
                    return null;
                
                return GetObjectNamespace(ModelNamespace);
            }
        }
        
       
        private string _namespaceName = null;
        public override string ModelNamespace
        {
            get
            {
                if(_namespaceName == null)
                {
                    XmlDocument doc = new XmlDocument();
                    doc.Load(_sourceSchemaPath);
                    SetModelNamespace(doc.DocumentElement.GetAttribute("Namespace"));
                }
                return _namespaceName;
            }
        }
        private void SetModelNamespace(string modelNamespace)
        {
            _namespaceName = modelNamespace;
            if(!String.IsNullOrEmpty(_namespaceName) &&
               EdmToObjectNamespaceMap.ContainsKey(EDM_NAMESPACE_HOLDER) && 
               !EdmToObjectNamespaceMap.ContainsKey(_namespaceName))
            {
                string objectNamespace = EdmToObjectNamespaceMap[EDM_NAMESPACE_HOLDER];
                EdmToObjectNamespaceMap.Add(_namespaceName, objectNamespace);
                EdmToObjectNamespaceMap.Remove(EDM_NAMESPACE_HOLDER);
            }
        }        
        
        private const string EDMX_NAMESPACE_V1 = "http://schemas.microsoft.com/ado/2007/06/edmx";
        private const string EDMX_NAMESPACE_V2 = "http://schemas.microsoft.com/ado/2008/10/edmx";
        private const string CSDL_NAMESPACE_V1 = "http://schemas.microsoft.com/ado/2006/04/edm";
        private const string CSDL_NAMESPACE_V2 = "http://schemas.microsoft.com/ado/2008/09/edm";
        private EdmItemCollection GetEdmItemCollectionFromEdmxAndSetNamespaceName(string sourceSchemaPath,
                                            System.CodeDom.Compiler.CompilerErrorCollection errorCollection)
        {
            XElement element = XElement.Load(sourceSchemaPath, LoadOptions.SetBaseUri | LoadOptions.SetLineInfo);

            XElement model = null;
            if(!TryGetModelNode(element, EDMX_NAMESPACE_V2, CSDL_NAMESPACE_V2, out model))
            {
                TryGetModelNode(element, EDMX_NAMESPACE_V1, CSDL_NAMESPACE_V1, out model);
            }
            
            if(model == null)
            {
                throw new InvalidOperationException("Unable to find the conceptual model node in the file " + sourceSchemaPath);
            }
            
            XmlReader xmlReader = null;
            try
            {
                // $Localized_Comment_550$ Set up the namespace.
                SetModelNamespace(model.Attribute("Namespace").Value);
                xmlReader = XmlReader.Create(model.CreateReader(), new XmlReaderSettings());
                return CreateEdmItemCollection(new XmlReader[] { xmlReader }, errorCollection);
            }
            finally
            {
                if (xmlReader != null)
                    ((IDisposable)xmlReader).Dispose();
            }
        }
        
        private bool TryGetModelNode(XElement edmxDocument, string edmxNamespace, string edmNamespace, out XElement model)
        {
            XNamespace edmx = edmxNamespace;
            XNamespace edm = edmNamespace;
            model = null;
            
            XElement runtime = edmxDocument.Element(edmx + "Runtime");
            if(runtime == null)
                return false;
                
            XElement modelSection = runtime.Element(edmx + "ConceptualModels");
            if(modelSection == null)
                return false;
                
            model = modelSection.Element(edm + "Schema");
            return model != null;
        }
        
        private EdmItemCollection CreateEdmItemCollection(IEnumerable<string> schemas, 
                                            System.CodeDom.Compiler.CompilerErrorCollection errorCollection)
        {
            List<XmlReader> readers = new List<XmlReader>();
            try
            {
                foreach(string schema in schemas)
                {
                    readers.Add(XmlReader.Create(schema));
                }
                
                return CreateEdmItemCollection(readers, errorCollection);
                
            }
            finally
            {
                foreach(XmlReader reader in readers)
                {
                    if(reader != null)
                    {
                        reader.Close();
                    }
                }
            }
        }

        private EdmItemCollection CreateEdmItemCollection(IEnumerable<XmlReader> schemas,
                                            System.CodeDom.Compiler.CompilerErrorCollection errorCollection)
        {
            IList<EdmSchemaError> errors;
            EdmItemCollection collection = System.Data.Entity.Design.MetadataItemCollectionFactory.CreateEdmItemCollection(schemas, out errors);
            if(errors.Any(e => e.Severity == EdmSchemaErrorSeverity.Error))
            {
                foreach(EdmSchemaError error in errors)
                {
                    System.CodeDom.Compiler.CompilerError newError = new System.CodeDom.Compiler.CompilerError(error.SchemaLocation, error.Line, error.Column, error.ErrorCode.ToString(CultureInfo.InvariantCulture), error.Message);
                    newError.IsWarning = error.Severity == EdmSchemaErrorSeverity.Warning;
                    if(error.SchemaLocation == null)
                    {
                        newError.FileName = _sourceSchemaPath;
                    }
                    errorCollection.Add(newError);
                }
                // $Localized_Comment_560$ Return an empty EdmItemCollection; the errors collection will indicate problems.
                return new EdmItemCollection();        
            }
            
            return collection;
        }
    }
    
    private abstract class WrapperBase
    {
        private readonly Microsoft.CSharp.CSharpCodeProvider _code;
        private readonly Dictionary<string, string> _edmToObjectNamespaceMap;
        private readonly string _modelNamespace;
        private readonly bool _fullyQualifySystemTypes;

        public WrapperBase(Dictionary<string, string> edmToObjectNamespaceMap, bool fullyQualifySystemTypes)
        {
            _code = new Microsoft.CSharp.CSharpCodeProvider();
            _edmToObjectNamespaceMap = edmToObjectNamespaceMap;
            _fullyQualifySystemTypes = fullyQualifySystemTypes;
        }
        
        public WrapperBase(WrapperBase wrapper)
        {
            // $Localized_Comment_570$ Get references to the existing objects.
            _code = wrapper._code;
            _modelNamespace = wrapper.ModelNamespace;
            _edmToObjectNamespaceMap = wrapper._edmToObjectNamespaceMap;
            _fullyQualifySystemTypes = wrapper._fullyQualifySystemTypes;
        }
        
        public virtual string SummaryComment{ get{ return GetMissingSummaryComment(); } }
        
        public virtual string GetMissingSummaryComment()
        {
            return GetResourceString("Template_CommentNoDocumentation");
        }
        
        public virtual string ModelNamespace { get{ return _modelNamespace; } }
        protected Dictionary<string, string> EdmToObjectNamespaceMap{ get { return _edmToObjectNamespaceMap; } }
        protected bool FullyQualifySystemTypes{ get{ return _fullyQualifySystemTypes; } }
        
        protected string GetObjectNamespace(string csdlNamespaceName)
        {
            string objectNamespace;
            if (_edmToObjectNamespaceMap.TryGetValue(csdlNamespaceName, out objectNamespace))
            {
                // $Localized_Comment_580$ This might be null.
                return objectNamespace;
            }

            return csdlNamespaceName;
        }
        
        private static string CreateFullName(string namespaceName, string name)
        {
            if (string.IsNullOrEmpty(namespaceName))
            {
                return name;
            }

            return namespaceName + "." + name;
        }

        protected string GetFullyQualifiedStructuralTypeName(StructuralType structuralType)
        {
            return Escape(CreateFullName(GetObjectNamespace(structuralType.NamespaceName), structuralType.Name));
        }
        
        protected string Escape(string identifier)
        {
            return _code.CreateEscapedIdentifier(identifier);
        }
        
        public string CreatePrimitiveValue(object value)
        {
            System.CodeDom.CodePrimitiveExpression expression = new System.CodeDom.CodePrimitiveExpression(value);
            StringWriter writer = new StringWriter();
            _code.GenerateCodeFromExpression(expression, writer, new System.CodeDom.Compiler.CodeGeneratorOptions());
            return writer.ToString();
        }

        protected string GetStructuralTypeName(StructuralType structuralType)
        {
            if (structuralType.NamespaceName == ModelNamespace)
            {
                return Escape(structuralType.Name);        
            }
            else
            {
                return Escape(CreateFullName(GetObjectNamespace(structuralType.NamespaceName), structuralType.Name));
            }
        }
        
        protected string GetTypeName(TypeUsage typeUsage)
        {
            if(typeUsage.EdmType is ComplexType ||
               typeUsage.EdmType is EntityType)
            {
                return GetStructuralTypeName((StructuralType)typeUsage.EdmType);
            }
            else if (typeUsage.EdmType is PrimitiveType)
            {
                Type clrType;
                string typeName = GetPrimitiveTypeName(typeUsage, out clrType);
                if(clrType.IsValueType && IsNullable(typeUsage))
                {
                    return string.Format(CultureInfo.InvariantCulture, "Nullable<{0}>", typeName);
                }
                return typeName;
            }
            if(typeUsage.EdmType is CollectionType)
            {
                CollectionType collection = (CollectionType)typeUsage.EdmType;
                return GetTypeName(collection.TypeUsage);
            }
            
            return "UnknownType";
        }

        protected string GetPrimitiveTypeName(TypeUsage typeUsage)
        {
            Type clrType;
            return GetPrimitiveTypeName(typeUsage, out clrType);
        }

        protected string GetPrimitiveTypeName(TypeUsage typeUsage, out Type clrType)
        {
            clrType = GetPrimitiveTypeClrType(typeUsage);
            string typeName = clrType.Name;
            
            if(FullyQualifySystemTypes)
            {
                typeName = "global::" + clrType.FullName;
            }
            
            return typeName;
        }
        
        protected Type GetPrimitiveTypeClrType(TypeUsage typeUsage)
        {
            return ((PrimitiveType)typeUsage.EdmType).ClrEquivalentType;
        }

        protected static string Entityize(string text)
        {
            if (string.IsNullOrEmpty(text))
                return "";

            text = text.Replace("&","&amp;");
            text = text.Replace("<","&lt;").Replace(">","&gt;");
            return text.Replace("\'","&apos;").Replace("\"","&quot;");
        }

        protected static string FixParameterName(string name)
        {
            // $Localized_Comment_590$ Change any property that is 'id' (case insensitive) to 'ID'
            // $Localized_Comment_600$ since 'iD' is a violation of FxCop rules.
            if (StringComparer.OrdinalIgnoreCase.Equals(name, "id"))
            {
                // $Localized_Comment_610$ Return all lower case since it is an abbreviation, not an acronym.
                return "id";
            }
            return CamelCase(name);
        }
        
        protected static TypeUsage GetElementType(TypeUsage typeUsage)
        {
            if(typeUsage == null)
                return null;
                
            if(typeUsage.EdmType is CollectionType)
            {
                return GetElementType(((CollectionType)typeUsage.EdmType).TypeUsage);
            }
            else
            {
                return typeUsage;
            }
        }

        protected static bool HasBaseMemberWithMatchingName(Type type, string memberName)
        {
            BindingFlags bindingFlags = BindingFlags.FlattenHierarchy | BindingFlags.NonPublic | BindingFlags.Public 
                        | BindingFlags.Instance | BindingFlags.Static;
            return type.GetMembers(bindingFlags).Where(m => IsVisibleMember(m)).Any(m => m.Name == memberName);
        }

        protected static bool IsVisibleMember(MemberInfo memberInfo)
        {
            if (memberInfo is EventInfo)
            {
                EventInfo ei = (EventInfo)memberInfo;
                MethodInfo add = ei.GetAddMethod();
                MethodInfo remove = ei.GetRemoveMethod();
                return IsVisibleMethod(add) || IsVisibleMethod(remove);
            }
            else if(memberInfo is FieldInfo)
            {
                FieldInfo fi = (FieldInfo)memberInfo;
                return !fi.IsPrivate && !fi.IsAssembly;
            }
            else if(memberInfo is MethodBase)
            {
                MethodBase mb = (MethodBase)memberInfo;
                if(mb.IsSpecialName)
                    return false;
                return IsVisibleMethod(mb);
            }
            else if(memberInfo is PropertyInfo)
            {
                PropertyInfo pi = (PropertyInfo)memberInfo;
                MethodInfo get = pi.GetGetMethod();
                MethodInfo set = pi.GetSetMethod();
                return IsVisibleMethod(get) || IsVisibleMethod(set);
            }
            
            return false;
        }
    
        protected static bool IsVisibleMethod(MethodBase methodBase)
        {
            if(methodBase == null)
                return false;
                
            return !methodBase.IsPrivate && !methodBase.IsAssembly;
        }
        
        private static bool IsNullable(TypeUsage typeUsage)
        {
            return (bool)typeUsage.Facets["Nullable"].Value;
        }
    }
    
    private class MetadataItemWrapper : WrapperBase
    {
        private readonly MetadataItem _item;
        public MetadataItemWrapper(MetadataItem item, WrapperBase wrapper)
        :base(wrapper)
        {
            _item = item;
        }
        
        protected MetadataItem Source { get{ return _item; } }
        public override string SummaryComment
        {
            get
            {
                if(Source.Documentation != null && Source.Documentation.Summary != null)
                {
                    return Entityize(Source.Documentation.Summary);
                }
                
                return GetMissingSummaryComment();
            }
        }
        
        public string GetLongDescriptionComment(int indentLevel)
        {
            if(Source.Documentation != null && !String.IsNullOrEmpty(Source.Documentation.LongDescription))
            {
                string comment = Environment.NewLine;
                string lineStart = GetIndent(indentLevel) + XMLCOMMENT_START + " ";
                comment += lineStart + "<LongDescription>" + Environment.NewLine;
                comment += lineStart + Entityize(Source.Documentation.LongDescription) + Environment.NewLine;
                comment += lineStart + "</LongDescription>";
                return comment;
            }
            return string.Empty;
        }
                
    }
    
    private class AssociationCodeWrapper : WrapperBase
    {
        private readonly AssociationType _associationType;
        public AssociationCodeWrapper(AssociationType associationType, WrapperBase wrapper)
        :base(wrapper)
        {
            _associationType = associationType;
        }
        
        public string ModelName{ get { return _associationType.Name; } }
        public string End0Name{ get{ return _associationType.AssociationEndMembers[0].Name; } }
        public string End0Multiplicity{ get { return GetEnumValueString(_associationType.AssociationEndMembers[0].RelationshipMultiplicity); } }
        public string End0TypeName{ get { return GetFullyQualifiedStructuralTypeName(_associationType.AssociationEndMembers[0].GetEntityType()); } }
        public string End1Name{ get { return _associationType.AssociationEndMembers[1].Name; } }
        public string End1Multiplicity{ get { return GetEnumValueString(_associationType.AssociationEndMembers[1].RelationshipMultiplicity); }  }
        public string End1TypeName{ get { return GetFullyQualifiedStructuralTypeName(_associationType.AssociationEndMembers[1].GetEntityType()); } }
        public bool IsForeignKey { get { return _associationType.IsForeignKey; } }
    }
    
    private class EntityContainerCodeWrapper : MetadataItemWrapper
    {
        public EntityContainerCodeWrapper(EntityContainer entityContainer, WrapperBase wrapper)
        :base(entityContainer, wrapper)
        {
        }
        
        protected new EntityContainer Source { get{ return (EntityContainer)base.Source; } }
        public string ModelName{ get{ return Source.Name;} }
        public string ClassName{ get{ return Escape(Source.Name); } }
        public string TypeAccessibility{ get{ return GetAccessibility(Source, TYPE_ACCESS); } }
        public IEnumerable<EntitySet> EntitySets{ get{ return Source.BaseEntitySets.OfType<EntitySet>(); } }
        public IEnumerable<FunctionImportMethodWrapper> FunctionImports
        { 
            get
            { 
                return Source.FunctionImports.Select(f => new FunctionImportMethodWrapper(f, this));
            }
        }
        public IEnumerable<EntitySetObjectSetPropertyWrapper> ObjectSetProperties{ get{ return EntitySets.Select(e => new EntitySetObjectSetPropertyWrapper(e, this)); } }
        public IEnumerable<EntitySetAddToMethodWrapper> AddToMethods{ get{ return EntitySets.Select(e => new EntitySetAddToMethodWrapper(e, this)); } }
    }
    
    private class EntitySetObjectSetPropertyWrapper : MetadataItemWrapper
    {
        public EntitySetObjectSetPropertyWrapper(EntitySet entitySet, WrapperBase wrapper)
        :base(entitySet, wrapper)
        {
        }
        
        protected new EntitySet Source { get{ return (EntitySet)base.Source; } }
        public string ModelName{ get { return Source.Name; } }
        public string PropertyName{ get { return Escape(Source.Name); } }
        public string FieldName{ get { return "_" + Source.Name; } }
        public string TypeName{ get { return GetStructuralTypeName(Source.ElementType); } }
        public string GetterAccessibility{ get { return GetAccessibility(Source, GETTER_ACCESS); } }
        public string NewModifier{ get { return HasBaseMemberWithMatchingName(typeof(ObjectContext), Source.Name) ? "new " : ""; } }
    }  

    private class EntitySetAddToMethodWrapper : WrapperBase
    {
        private readonly EntitySet _entitySet;
        public EntitySetAddToMethodWrapper(EntitySet entitySet, WrapperBase wrapper)
        :base(wrapper)
        {
            _entitySet = entitySet;
        }
        
            public string ModelName{ get { return _entitySet.Name; } }
            public string TypeName{ get { return GetStructuralTypeName(_entitySet.ElementType); } }
            public string EntityAccessibility{ get { return GetAccessibility(_entitySet.ElementType, TYPE_ACCESS); } }
            public string Parameter{ get { return Escape(FixParameterName(_entitySet.ElementType.Name)); } }
            public override string SummaryComment { get{ return String.Format(CultureInfo.CurrentCulture, GetResourceString("Template_GenCommentAddToMethodCs"), ModelName); } }
    }

    private class FunctionImportMethodWrapper : MetadataItemWrapper
    {
        private readonly List<FunctionImportParameterWrapper> _parameters;
        public FunctionImportMethodWrapper(EdmFunction edmFunction, WrapperBase wrapper)
        :base(edmFunction, wrapper)
        {
            UniqueIdentifierService uniqueIdentifier = new UniqueIdentifierService();
            _parameters = Source.Parameters.Select(p => new FunctionImportParameterWrapper(p, this, uniqueIdentifier)).ToList();
            _parameters.ForEach(p => p.SetupLocalVariableName(uniqueIdentifier));
        }
        
        protected new EdmFunction Source { get{ return (EdmFunction)base.Source; } }
        public string ModelName{ get{ return Source.Name; } }
        public string FunctionName{ get{ return Escape(Source.Name); } }
        public string ReturnElementTypeName{ get{ return Source.ReturnParameter == null ? null : GetTypeName(GetElementType(Source.ReturnParameter.TypeUsage)); } }
        public EdmType ReturnElementType{ get{ return Source.ReturnParameter == null ? null : GetElementType(Source.ReturnParameter.TypeUsage).EdmType; } }
        public string MethodAccessibility{ get{ return GetAccessibility(Source, METHOD_ACCESS); } }
        public string NewModifier{ get{ return HasBaseMemberWithMatchingName(typeof(ObjectContext), Source.Name) ? "new " : ""; } }
        public List<FunctionImportParameterWrapper> Parameters{ get{ return _parameters; } }
        public string ParameterList
        { 
            get
            { 
                return _parameters.Aggregate(string.Empty, (string accumulated, FunctionImportParameterWrapper input) =>
                    {
                        string prefix = ", ";
                        if (accumulated == string.Empty)
                        {
                            prefix = string.Empty;
                        }
                        return accumulated + prefix + input.TypeName + " " + input.FunctionParameterName;
                     });
             }
        }
        public string QueryExecuteParameterNameList{ get{ return _parameters.Select(p => p.NeedsLocalVariable ? p.LocalVariableName : p.FunctionParameterName).Aggregate(string.Empty, (string accumulated, string input) => {return accumulated + ", " + input;}); } }
        public string ParameterComments 
        { 
            get
            { 
                System.Text.StringBuilder builder = new System.Text.StringBuilder();
                foreach(FunctionImportParameterWrapper parameter in Parameters)
                {
                    builder.AppendLine();
                    builder.Append(GetIndent(1));
                    builder.Append(XMLCOMMENT_START);
                    builder.Append(String.Format(CultureInfo.InvariantCulture, " <param name=\"{0}\">{1}</param>", parameter.RawName, parameter.SummaryComment));
                }
                return builder.ToString(); 
            }
        }
    }
    
    private class FunctionImportParameterWrapper : MetadataItemWrapper
    {
        private readonly string _rawName;
        private string _localVariableName;
        public FunctionImportParameterWrapper(FunctionParameter parameter, WrapperBase wrapper, UniqueIdentifierService uniqueIdentifier)
        :base(parameter, wrapper)
        {
            _rawName = uniqueIdentifier.AdjustIdentifier(CamelCase(Source.Name));
            
        }
        
        protected new FunctionParameter Source { get{ return (FunctionParameter)base.Source; } }
        
        public string FunctionParameterName{ get{ return Escape(_rawName); } }
        public string RawName{ get{ return _rawName; } }
        public string TypeName{ get{ return Source.Mode == ParameterMode.In ? GetTypeName(Source.TypeUsage) : "ObjectParameter"; } }
        public string EsqlParameterName{ get{ return Source.Name; } }
        public string RawClrTypeName{ get{ return GetPrimitiveTypeName(Source.TypeUsage); } }
        public bool IsNullableT{ get{ return GetPrimitiveTypeClrType(Source.TypeUsage).IsValueType; } }
        public bool NeedsLocalVariable{ get{ return Source.Mode == ParameterMode.In; } }
        public string LocalVariableName{ get{ return _localVariableName; } }
        
       // $Localized_Comment_620$ Setup is done in a second pass to enable easy validation by making the Microsoft 
       // $Localized_Comment_630$ Intermediate Language (MSIL) of the method match the output of the EntityClassGenerator.
        public void SetupLocalVariableName(UniqueIdentifierService uniqueIdentifier)
        {
            if(! NeedsLocalVariable)
                return;
            
            _localVariableName = uniqueIdentifier.AdjustIdentifier(CamelCase(Source.Name) + "Parameter");
        }
    }
    
    private class StructuralTypeWrapper : MetadataItemWrapper
    {
        public StructuralTypeWrapper(StructuralType type, WrapperBase wrapper)
        :base(type, wrapper)
        {
        }
        
        protected new  StructuralType Source{ get{ return (StructuralType)base.Source; } }
        public string ModelName{ get{ return Source.Name; } }
        public string ModelFullName{ get{ return Source.FullName; } }
        public string ClassName{ get{ return Escape(Source.Name); } }
        public string TypeAccessibility{ get{ return GetAccessibility(Source, TYPE_ACCESS); } }
        public FactoryMethodWrapper FactoryMethodWrapper{ get{ return new FactoryMethodWrapper(Source, this); } }
        public IEnumerable<PrimitiveTypePropertyWrapper> PrimitiveTypeProperties{ get{ return GetProperties().Where(p => p.DeclaringType == Source && p.TypeUsage.EdmType is PrimitiveType).Select(p => new PrimitiveTypePropertyWrapper(p, this)); } }
        public IEnumerable<ComplexTypePropertyWrapper> ComplexTypeProperties{ get{ return GetProperties().Where(p => p.DeclaringType == Source && p.TypeUsage.EdmType is ComplexType).Select(p => new ComplexTypePropertyWrapper(p, this)); } }

        private IEnumerable<EdmProperty> GetProperties()
        {
            if(Source.BuiltInTypeKind == BuiltInTypeKind.EntityType)
            {
                return ((EntityType)Source).Properties;
            }
            else
            {
                return ((ComplexType)Source).Properties;
            }
        }
        
        public bool HasDeclaredMemberWithName(string name)
        {
            return GetAllDeclaredMembers().Any(m => m.Name == name);  
        }
        
        private IEnumerable<EdmMember> GetAllDeclaredMembers()
        {
            if(Source is EntityType)
            {
                EntityType entity = (EntityType)Source;
                IEnumerable<EdmMember> declaredMembers = entity.Members.Where(m => m.DeclaringType == entity);
                IEnumerable<NavigationProperty> decalredNavigationProperties = entity.NavigationProperties.Where(n => n.DeclaringType == entity);
                
                return declaredMembers.Union(decalredNavigationProperties.Cast<EdmMember>());
            }
            
            return Source.Members.Where(m => m.DeclaringType == Source);
        }
    }
    
    private class EntityTypeWrapper : StructuralTypeWrapper 
    {
        public EntityTypeWrapper(EntityType entity, WrapperBase wrapper)
        :base(entity, wrapper)
        {
        }
        
        public new EntityType Source{ get{ return (EntityType)base.Source; } }

        public string AbstractOption{ get{ return Source.Abstract ? "abstract " : ""; } }
        public bool IsAbstract{ get{ return Source.Abstract; } }
        public string BaseTypeName{ get{ return Source.BaseType == null ? "EntityObject" : GetStructuralTypeName((StructuralType)Source.BaseType); } }
        public string TypeReferenceName{ get{ return GetStructuralTypeName(Source); } }
        
        public IEnumerable<NavigationPropertyWrapper> NavigationProperties{ get{ return Source.NavigationProperties.Where(n => n.DeclaringType == Source).Select(n => new NavigationPropertyWrapper(n, this)); } }
    }

    private class PropertyWrapper : MetadataItemWrapper
    {
        private readonly string _propertyAccessibility;
        private readonly string _setterAccessibility;
        private readonly string _getterAccessibility;

        public PropertyWrapper(EdmMember member, WrapperBase wrapper)
        :base(member, wrapper)
        {
            GetPropertyAccessibility(Source, out _propertyAccessibility, out _getterAccessibility, out _setterAccessibility);
        }

        protected new EdmMember Source{ get{ return (EdmMember)base.Source; } }
        public string PropertyAccessibility{ get{ return _propertyAccessibility; } }
        public string GetterAccessibility{ get{ return _getterAccessibility == string.Empty ? string.Empty : _getterAccessibility + " "; } }
        public string SetterAccessibility{ get{ return _setterAccessibility == string.Empty ? string.Empty : _setterAccessibility + " "; } }
        public string Name { get{ return Escape(Source.Name); } }
        public string ModelName { get{ return Source.Name; } }
        public string NewModifier { get{ return HasBaseMemberWithMatchingName(typeof(EntityObject), Source.Name) ? "new " : ""; } }
        
    }
    
    private class NavigationPropertyWrapper : PropertyWrapper
    {
        public NavigationPropertyWrapper(NavigationProperty edmProperty, WrapperBase wrapper)
        :base(edmProperty, wrapper)
        {
        }
    
        public new NavigationProperty Source{ get{ return (NavigationProperty)base.Source; } }
        public string ElementType { get{ return GetStructuralTypeName(Source.ToEndMember.GetEntityType()); } }
        public string RelationshipFullName { get{ return Source.RelationshipType.FullName; } }
        public string RelationshipNamespace { get{ return Source.RelationshipType.NamespaceName; } }
        public string RelationshipName { get{ return Source.RelationshipType.Name; } }
        
        public string RefPropertyName{ get{ return Source.Name + "Reference"; } }

        public string ToRoleName { get{ return Source.ToEndMember.Name; } }
        public RelationshipMultiplicity ToMultiplicity{ get { return Source.ToEndMember.RelationshipMultiplicity; } }
    }
    
    private class ComplexTypeWrapper : StructuralTypeWrapper
    {
        public ComplexTypeWrapper(ComplexType complex, WrapperBase wrapper)
        :base(complex, wrapper)
        {
        }
        
        public new ComplexType Source{ get{ return (ComplexType)base.Source; } }
        public string BaseTypeName{ get{ return Source.BaseType == null ? "ComplexObject" : GetStructuralTypeName((StructuralType)Source.BaseType); } }
    }

    private class FactoryMethodWrapper : StructuralTypeWrapper
    {
        private readonly string _instanceName;
        private readonly List<FactoryMethodParameterWrapper> _parameters;

        public FactoryMethodWrapper(StructuralType type, WrapperBase wrapper)
        :base(type, wrapper)
        {
            UniqueIdentifierService uniqueIdentifier = new UniqueIdentifierService();
            _instanceName = Escape(uniqueIdentifier.AdjustIdentifier((CamelCase(Source.Name))));
            IEnumerable<EdmProperty> properties = Source.Members.OfType<EdmProperty>().Where(p => IncludePropertyInFactoryMethod(p));
            _parameters = properties.Select(p => new FactoryMethodParameterWrapper(p, this, uniqueIdentifier)).ToList();
        }
        
        public string InstanceName{ get{ return _instanceName; } }
        public string MethodName{ get{ return "Create" + Source.Name; } }
        public List<FactoryMethodParameterWrapper> Parameters{ get{ return _parameters; } }
        public string ParameterDeclarationList
        { 
            get
            { 
                return _parameters.Aggregate(string.Empty, (string accumulated, FactoryMethodParameterWrapper input) =>
                    {
                        string prefix = ", ";
                        if (accumulated == string.Empty)
                        {
                            prefix = string.Empty;
                        }
                        return accumulated + prefix + input.TypeName + " " + input.Name;
                     });
             }
         }

        public string ParameterComments
        {
            get
            {
                System.Text.StringBuilder builder = new System.Text.StringBuilder();
                foreach(FactoryMethodParameterWrapper parameter in Parameters)
                {
                    builder.AppendLine();
                    builder.Append(GetIndent(1));
                    builder.Append(XMLCOMMENT_START);
                    builder.Append(String.Format(CultureInfo.InvariantCulture, " <param name=\"{0}\">", parameter.RawName));
                    builder.Append(String.Format(CultureInfo.CurrentCulture, GetResourceString("Template_CommentFactoryMethodParam"), parameter.PropertyModelName));
                    builder.Append("</param>");
                }
                return builder.ToString();
            }
        }        
            
        private bool IncludePropertyInFactoryMethod(EdmProperty edmProperty)
        {
            if (edmProperty.Nullable)
            {
                return false;
            }
            
            if (edmProperty.DefaultValue != null)
            {
                return false;
            }
            
            if(GetAccessibility(edmProperty, GETTER_ACCESS) != "public" &&
               GetAccessibility(edmProperty, SETTER_ACCESS) != "public")
            {
                // $Localized_Comment_640$ There is no public part to the property.
                return false;
            }

            return true;
        }
    }
    
    private class FactoryMethodParameterWrapper : WrapperBase
    {
        private readonly EdmProperty _property;
        private readonly string _rawName;

        public FactoryMethodParameterWrapper(EdmProperty edmProperty, WrapperBase wrapper, UniqueIdentifierService uniqueIdentifier)
        :base(wrapper)
        {
            _property = edmProperty;
            _rawName = uniqueIdentifier.AdjustIdentifier(FixParameterName(_property.Name));
        }
    
        public string TypeName{ get{ return GetTypeName(_property.TypeUsage); } }
        public string Name{ get{ return Escape(_rawName); } }
        public string RawName{ get{ return _rawName; } }
        public string PropertyName{ get{ return Escape(_property.Name); } }
        public string PropertyModelName{ get{ return _property.Name; } }
        public bool IsComplexType{ get{ return _property.TypeUsage.EdmType is ComplexType; } }
    }
    
    
  
    private class DataPropertyWrapper : PropertyWrapper
    {
        public DataPropertyWrapper(EdmProperty edmProperty, WrapperBase wrapper)
        :base(edmProperty, wrapper)
        {
        }
        public new EdmProperty Source{ get{ return (EdmProperty)base.Source; } }
        public string PropertyType { get{ return GetTypeName(Source.TypeUsage); } }
        public string FieldName { get{ return "_" + Source.Name; } }
        public string ChangingMethodName { get{ return string.Format(CultureInfo.InvariantCulture, "On{0}Changing", Source.Name); } }
        public string ChangedMethodName { get{ return string.Format(CultureInfo.InvariantCulture, "On{0}Changed", Source.Name);  } }   
    }

    private class PrimitiveTypePropertyWrapper : DataPropertyWrapper
    {
        public PrimitiveTypePropertyWrapper(EdmProperty edmProperty, WrapperBase wrapper)
        :base(edmProperty, wrapper)
        {
        }
        public bool IsKeyProperty { get{ return Source.DeclaringType.BuiltInTypeKind != BuiltInTypeKind.EntityType ? false : ((EntityType)Source.DeclaringType).KeyMembers.Contains(Source); } }
        public bool IsByteArray{ get{ return GetPrimitiveTypeClrType(Source.TypeUsage) == typeof(byte[]); } }
        public bool IsNullable { get{ return Source.Nullable; } }
        public string FieldInit { get{ return GetFieldPropertyInitialization(Source); } }
        public string SetValidValueOptionalNullableParameter
        {
            get
            {
                string list = string.Empty;
                if (((PrimitiveType)Source.TypeUsage.EdmType).ClrEquivalentType.IsClass)
                {
                    list += ", " + CreatePrimitiveValue(IsNullable);
                }
                return list;
            }
        }

        private string GetFieldPropertyInitialization(EdmProperty property)
        {
            if(property.DefaultValue == null)
                return null;
            
            Type clrType = GetPrimitiveTypeClrType(property.TypeUsage);
            if(clrType == typeof(Guid))
            {
                return string.Format(CultureInfo.InvariantCulture, "new Guid(\"{0}\")", ((Guid)property.DefaultValue).ToString("D", CultureInfo.InvariantCulture));
            }
            else if(clrType == typeof(DateTime))
            {
                return string.Format(CultureInfo.InvariantCulture, "new DateTime({0}, DateTimeKind.Unspecified)", ((DateTime)property.DefaultValue).Ticks);
            }
            else if(clrType == typeof(byte[]))
            {
                string arrayInit = ((byte[])property.DefaultValue).Aggregate(string.Empty, (string accumulated, byte input) => {return accumulated == string.Empty ? input.ToString() : accumulated + ", " + input.ToString(CultureInfo.InvariantCulture);});
                return string.Format(CultureInfo.InvariantCulture, "new byte [] {{{0}}}", arrayInit);
            }
            else if(clrType == typeof(DateTimeOffset))
            {
                DateTimeOffset dto = (DateTimeOffset)property.DefaultValue;
                return string.Format(CultureInfo.InvariantCulture, "new DateTimeOffset({0}, new TimeSpan({1}))", dto.Ticks, dto.Offset.Ticks);
            }
            
            return CreatePrimitiveValue(property.DefaultValue);
        }

    }
    
    private class ComplexTypePropertyWrapper : DataPropertyWrapper
    {
        public ComplexTypePropertyWrapper(EdmProperty edmProperty, WrapperBase wrapper)
        :base(edmProperty, wrapper)
        {
        }

        public string InitializedTrackingField{ get{ return "_" + ModelName + "Initialized"; } }
    }
#>
